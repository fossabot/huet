(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{51:function(e,t,a){"use strict";a.r(t),a.d(t,"default",function(){return r});var n=a(0),l=a.n(n),i=a(19),o=Object(i.a)({"p, ul":{lineHeight:1.25}});function r(){return l.a.createElement("div",{className:"center measure f4 ".concat(o)},l.a.createElement("h1",null,"How and Why"),l.a.createElement("p",null,"This project combines a few ideas:"),l.a.createElement("ul",null,l.a.createElement("li",null,"Take lessons from dataviz for building UIs"),l.a.createElement("li",null,"Set colors in your UI by specifying desired contrast, not the hex code or a variable that points to a specific color.")),l.a.createElement("p",null,"Dataviz people are ahead of UI designers in understanding the limitations of standard color systems (RGB, HEX, HSL, HSB)."),l.a.createElement("p",null,"When you pick colors using something like the Photoshop color picker, you learn that 100% brightness for yellow looks different than 100% brightness for a color like blue. This inconsistency may seem odd but it's what allows for a simple and intuitive interface for picking colors."),l.a.createElement("p",null,"Picking colors for user interfaces poses a set of problems that you don't see in traditional design work. If you changed an existing color to a new one in in a print design, it's fairly straightforward to look through your design and have confidence that a new color hasn't created any issues. With apps, it's difficult even when you have a component library or design system."),l.a.createElement("p",null,"It's difficult to change existing colors for any of the reasons you might want to:"),l.a.createElement("ul",null,l.a.createElement("li",null,"Experimenting with a new look"),l.a.createElement("li",null,"Increasing accessibility"),l.a.createElement("li",null,"Differentiating modes and different parts of your app"),l.a.createElement("li",null,"Allowing users to customize their experience"),l.a.createElement("li",null,"Shifting your colors to adapt to an image or a logo")),l.a.createElement("p",null,'The rationale for having a comprehensive way of thinking about color interactions becomes more clear if we think about various states and modes as themes, or variations of existing themes. Sometimes we want to apply "themes" to all or part of the UI. Some examples:'),l.a.createElement("ul",null,l.a.createElement("li",null,"Dark mode"),l.a.createElement("li",null,"Admin mode"),l.a.createElement("li",null,"Incognito mode"),l.a.createElement("li",null,"Disabled state"),l.a.createElement("li",null,"Hover state"),l.a.createElement("li",null,"Selected state")),l.a.createElement("p",null,"Using Huet increases your flexibility in making large retheming changes. However, it comes with an important limitation. It doesn't let you specify whether a given element will be lighter or darker than its background. The library will make that choice for you. I intend to make this limitation as painless as possible over time."),l.a.createElement("p",null,"Losing the flexibility to directly choose the lightness of your component may seem like a big limitation, but it's' what makes Huet possible. This means Huet may not be right for every project. Some examples:"),l.a.createElement("ul",null,l.a.createElement("li",null,"You have relatively flat views. This means your visual heirarchy is largely determined by size, spacing, and text color. EX: your backgrounds are constistently some standard color throughout your entire app (usually white)."),l.a.createElement("li",null,"You have bespoke UIs where designers have enough time and control to produce very polished designs."),l.a.createElement("li",null,"You have a simple app with few views."),l.a.createElement("li",null,"You have designers who have the time and ability to create a flexible, focused pallet.")))}}}]);
//# sourceMappingURL=8.fb4d139e.chunk.js.map